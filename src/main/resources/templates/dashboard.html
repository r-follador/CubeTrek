<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <link rel="icon" type="image/svg" href="/assets/logo.svg">
    <title>CubeTrek - Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src=" https://cdn.jsdelivr.net/npm/bootstd3.rap@5.3.2/dist/js/bootstrap.min.js "></script>
    <link href=" https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css " rel="stylesheet">
    <link href="../css/dashboard.css" rel="stylesheet">
    <script src=" https://cdn.jsdelivr.net/npm/maplibre-gl@3.1.0/dist/maplibre-gl.min.js "></script>
    <link href=" https://cdn.jsdelivr.net/npm/maplibre-gl@3.1.0/dist/maplibre-gl.min.css " rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>

    <style>
        .hover-row:hover {
            background-color: rgba(185, 211, 246, 0.32);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .animated-div {
            animation-name: fadeIn;
            animation-duration: 5s; /* Adjust the time as needed */
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .blinking-dot {
            animation: blink 1s infinite;
        }
    </style>
</head>
<body>
<svg width="0" height="0">
    <defs>
        <linearGradient id="altitude-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#6568b5"></stop>
            <stop offset="100%" stop-color="#c8cafa"></stop>
        </linearGradient>
    </defs>
</svg>
<header th:fragment="header" class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0 shadow">
    <a class="navbar-brand col-md-3 col-lg-2 me-0 px-3" href="#"><img class="me-2" src="/assets/logo.svg" width="30">CubeTrek</a>
    <button class="navbar-toggler position-absolute d-md-none collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#sidebarMenu" aria-controls="sidebarMenu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="w-100"></div>
    <ul class="navbar-nav px-3">
        <a class="nav-link" href="#" data-bs-toggle="modal" data-bs-target="#settingsModal">
            <img src="../assets/cubetrek_settings.svg" height="20px"></a>
    </ul>
    <div class="navbar-nav">
        <div class="nav-item text-nowrap">
            <a class="nav-link px-3" href="#" th:href="@{/logout}">Sign out</a>
        </div>
    </div>
</header>

<div class="container-fluid">
    <div th:with="field='dashboard'" class="row">
        <nav th:fragment="navigation (field)" id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
            <div class="position-sticky pt-3">
                <ul class="nav flex-column">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/dashboard" th:classappend="${field=='dashboard' ? 'active' : ''}">
                            Dashboard
                        </a>
                    </li>

                    <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                        <span>My Activities</span>
                    </h6>


                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/activities" th:classappend="${field=='activitylist' ? 'active' : ''}">
                            List
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/trekmapper" th:classappend="${field=='activitymap' ? 'active' : ''}">
                            TrekMapper
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/matched_activities" th:classappend="${field=='matchingactivities' ? 'active' : ''}">
                            Matched Activities
                        </a>
                    </li>
                </ul>

                <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
                    <span>Your Profile</span>
                    <a class="link-secondary" href="#" aria-label="Add a new report">
                        <span data-feather="plus-circle"></span>
                    </a>
                </h6>
                <ul class="nav flex-column mb-2">
                    <li class="nav-item">
                        <a class="nav-link" href="/upload" th:classappend="${field=='upload' ? 'active' : ''}">
                            Upload Activities
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/profile" th:classappend="${field=='profile' ? 'active' : ''}">
                            Profile
                        </a>
                    </li>
                </ul>
            </div>
        </nav>
    </div>

    <div class="row">
        <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">

            <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                <h1 class="h2">Dashboard</h1>
                <div th:if="${user.getUserTier()==T(com.cubetrek.database.Users.UserTier).PAID}">
                    <img src="assets/trophy-icon.svg" style="width: 30px; height: 30px;">
                    <span class="badge text-bg-warning">You're a Supporter!</span>
                </div>
            </div>

            <div th:if="${totalActivities < 5}" class="card m-5" style="width: 18rem;">
                <div class="card-body">
                    <h5 class="card-title" th:if="${totalActivities == 0}">Your Profile is empty üòî</h5>
                    <h5 class="card-title" th:unless="${totalActivities == 0}">Your Profile is almost empty üòî</h5>
                    <p class="card-text">Add your Tracks to get started. Upload your files, link your Garmin, Polar and Coros account to automatically sync future activities.</p>
                    <a href="/upload" class="btn btn-primary m-1">Upload Activity Files</a>
                    <a href="/profile" class="btn btn-primary m-1">Link Accounts</a>
                </div>
            </div>

            <div th:if="${totalActivities >= 10 and user.getUserTier()==T(com.cubetrek.database.Users.UserTier).FREE}" onclick="window.location='/subscribe';" style="cursor: pointer;" class="animated-div" >
                <div class="card-body">
                    <h5 class="card-title">Support CubeTrek</h5>
                    <p class="card-text">Become a üèÜ<a href="/subscribe">subscriber</a> and help pay the CubeTrek bills!</p>
                </div>
            </div>

            <div th:if="${totalActivities >= 5}" class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2">
                <div class="h4">
                    <span>Personal Heatmap</span>
                    <div class="btn-group">
                        <a class="btn btn-light btn-sm" id="heatmaptype" data-bs-toggle="dropdown" aria-expanded="false">
                        Distance per Day
                        </a>
                        <ul class="dropdown-menu">
                        <li><a class="dropdown-item" onclick="heatmapChange('distance')">Distance</a></li>
                        <li><a class="dropdown-item" onclick="heatmapChange('ascent')">Ascent</a></li>
                        <li><a class="dropdown-item" onclick="heatmapChange('number')">Number of Activities</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="flex-grow-1 p-0 m-0" id="graph" style="width:100%">
            </div>
            <div th:if="${totalActivities >= 5}">
                <div class="pt-3">
                    <div class="row">
                        <!-- Bar Graph Section -->
                        <div class="col-xxl-6 mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div class="d-flex align-items-center">
                                    <div class="h4 mb-0">
                                        <span>Totals</span>
                                    </div>
                                    <div class="btn-group ms-3">
                                        <a class="btn btn-light btn-sm" id="barGraphButton" data-bs-toggle="dropdown" aria-expanded="false">
                                            Activitytype
                                        </a>
                                        <ul class="dropdown-menu" id="barGraphDropdown">
                                        </ul>
                                        <a class="btn btn-light btn-sm" id="barGraphButton2" data-bs-toggle="dropdown" aria-expanded="false">
                                            Distance
                                        </a>
                                        <ul class="dropdown-menu" id="barGraphDropdown2">
                                            <li><a class="dropdown-item" onclick="updateBargraphType('distance')">Distance</a></li>
                                            <li><a class="dropdown-item" onclick="updateBargraphType('ascent')">Ascent</a></li>
                                        </ul>
                                        <a class="btn btn-light btn-sm" id="barGraphButton3" onclick="updateBargraphTime()">
                                            Monthly
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <div id="bargraph" style="width: 100%; height: 400px;"></div>
                        </div>

                        <!-- Cumulative Graph Section -->
                        <div class="col-xxl-6 mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div class="d-flex align-items-center">
                                    <div class="h4 mb-0">
                                        <span>Annual Comparison</span>
                                    </div>
                                    <div class="btn-group ms-3">
                                        <a class="btn btn-light btn-sm" id="cumgraphButton" data-bs-toggle="dropdown" aria-expanded="false">
                                            Activitytype
                                        </a>
                                        <ul class="dropdown-menu" id="cumgraphDropdow">
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div id="cumgraph" style="width: 100%; height: 400px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2">
                <h4 class="h4">Recent Activities</h4>
            </div>

            <div class="alert alert-danger" role="alert" id="errorbox" style="display:none;">
                Error fetching data
            </div>


            <div id="recenttablebody" class="d-flex flex-wrap">

            </div>
            <a href="/activities" th:if="${totalActivities > 10}" type="button" class="btn btn-outline-primary" th:text="'View '+ ${totalActivities} + ' Activities'">View All Activities</a>

            <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2">
                <h4 class="h4">Best Of</h4>
            </div>

            <div class="row">

                <div class="col-lg-4">
                    <h6 class="h6">Furthest Distances</h6>
                    <ul class="nav nav-tabs" id="TabFurthest" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="furthest-recent-tab" data-bs-toggle="tab" data-bs-target="#furthest-recent-pane" type="button" role="tab" aria-controls="furthest-recent-pane" aria-selected="true">Last 3 Month</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="furthest-alltime-tab" data-bs-toggle="tab" data-bs-target="#furthest-alltime-pane" type="button" role="tab" aria-controls="furthest-alltime-pane" aria-selected="false">All-Time</button>
                        </li>
                    </ul>
                    <div class="tab-content" id="TabFurthestContent">
                        <div class="tab-pane fade show active" id="furthest-recent-pane" role="tabpanel" aria-labelledby="furthest-recent-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Distance</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.recentDistance.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.recentDistance}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-longdist="${track.getDistance()}" th:text="${track.getDistance()}"> Distance </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="tab-pane fade" id="furthest-alltime-pane" role="tabpanel" aria-labelledby="furthest-alltime-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Distance</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.alltimeDistance.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.alltimeDistance}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-longdist="${track.getDistance()}" th:text="${track.getDistance()}"> Distance </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="col-lg-4">
                    <h6 class="h6">Furthest Climbs</h6>
                    <ul class="nav nav-tabs" id="TabAscent" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="ascent-recent-tab" data-bs-toggle="tab" data-bs-target="#ascent-recent-pane" type="button" role="tab" aria-controls="ascent-recent-pane" aria-selected="true">Last 3 Month</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="ascent-alltime-tab" data-bs-toggle="tab" data-bs-target="#ascent-alltime-pane" type="button" role="tab" aria-controls="ascent-alltime-pane" aria-selected="false">All-Time</button>
                        </li>
                    </ul>
                    <div class="tab-content" id="TabAscentContent">
                        <div class="tab-pane fade show active" id="ascent-recent-pane" role="tabpanel" aria-labelledby="ascent-recent-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Ascent</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.recentAscent.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.recentAscent}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-shortdist="${track.getElevationup()}" th:text="${track.getElevationup()}"> Ascent </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="tab-pane fade" id="ascent-alltime-pane" role="tabpanel" aria-labelledby="ascent-alltime-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Ascent</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.alltimeAscent.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.alltimeAscent}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-shortdist="${track.getElevationup()}" th:text="${track.getElevationup()}"> Ascent </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="col-lg-4">
                    <h6 class="h6">Highest Peaks</h6>
                    <ul class="nav nav-tabs" id="TabPeaks" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="peaks-recent-tab" data-bs-toggle="tab" data-bs-target="#peaks-recent-pane" type="button" role="tab" aria-controls="peaks-recent-pane" aria-selected="true">Last 3 Month</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="peaks-alltime-tab" data-bs-toggle="tab" data-bs-target="#peaks-alltime-pane" type="button" role="tab" aria-controls="peaks-alltime-pane" aria-selected="false">All-Time</button>
                        </li>
                    </ul>
                    <div class="tab-content" id="TabPeaksContent">
                        <div class="tab-pane fade show active" id="peaks-recent-pane" role="tabpanel" aria-labelledby="peaks-recent-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Highest Point ASL</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.recentPeak.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.recentPeak}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-shortdist="${track.getHighestpoint()}" th:text="${track.getHighestpoint()}"> Highest Point </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="tab-pane fade" id="peaks-alltime-pane" role="tabpanel" aria-labelledby="peaks-alltime-tab" tabindex="0">
                            <table class="table">
                                <thead class="table-header">
                                <tr>
                                    <th></th>
                                    <th>Date</th>
                                    <th>Title</th>
                                    <th>Highest Point ASL</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:if="${topTracks.alltimePeak.empty}">
                                    <td colspan="2"><i>No Activities</i></td>
                                </tr>
                                <tr th:each="track : ${topTracks.alltimePeak}">
                                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                                             th:title="${track.activitytype.getDisplayValue()}"></td>
                                    <td><span th:data-date="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                                    <td><span th:data-shortdist="${track.getHighestpoint()}" th:text="${track.getHighestpoint()}"> Highest Point </span></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2">
                <h4 class="h4"><img src='../assets/icon_favorite_select.svg' height='15px'> My Favorites <img src='../assets/icon_favorite_select.svg' height='15px'></h4>
            </div>

            <table class="table">
                <thead>
                <tr>
                    <th></th>
                    <th> Date </th>
                    <th> Title </th>
                    <th> Duration </th>
                    <th> Ascent</th>
                    <th> Distance</th>
                    <th> </th>
                </tr>
                </thead>
                <tbody>
                <tr th:if="${favoriteTracks.empty}">
                    <td colspan="2"><i>No favorite Activities, mark them by clicking the star ‚≠ê</i></td>
                </tr>
                <tr th:each="track : ${favoriteTracks}">
                    <td><img height="30px" th:src="${'../assets/'+track.activitytype.getIconName()}"
                             th:title="${track.activitytype.getDisplayValue()}"></td>
                    <td><span th:data-datetime="${track.getDatetrack()}" th:text="${track.getDatetrack()}"> Date </span></td>
                    <td><a th:href="'/view/'+${track.getId()}" th:text="${track.getTitle()}"> Title </a></td>
                    <td><span th:data-duration="${track.getDuration()}" th:text="${track.getDuration()}"> Duration </span></td>
                    <td><span th:data-shortdist="${track.getElevationup()}" th:text="${track.getElevationup()}"> Ascent </span></td>
                    <td><span th:data-longdist="${track.getDistance()}" th:text="${track.getDistance()}"> Distance </span></td>
                    <td><span th:if="${track.getTrackgroup() != null}"> <a th:href="'/matching/'+${track.getTrackgroup()}"><img src="/assets/matched.svg" title="Matching Activities"></a></span></td>
                </tr>
                </tbody>
            </table>

        </main>
    </div>
</div>
<div class="modal fade" id="settingsModal" tabindex="-1" style="display: none;" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Settings</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">

                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="metricChecked" onclick="clickSettingsMetric()">
                    <label class="form-check-label" for="metricChecked" id="metricCheckedLabel">Metric Units</label>
                </div>

            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="heatmapModal" tabindex="-1" style="display: none;" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="heatmapModalTitle">Activity</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <table class="table table-hover">
                    <thead>
                    <tr>
                        <th></th>
                        <th> Date</th>
                        <th> Title </th>
                        <th> Duration</th>
                        <th> Ascent</th>
                        <th> Distance </th>
                    </tr>
                    </thead>
                    <tbody id="poptable">
                    </tbody>
                </table>

            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="editModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Edit Track</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-danger" style="display: none;" id="errormessageedit" role="alert">
                </div>
                <div class="alert alert-success" style="display: none;" id="successmessageedit" role="alert">
                </div>
                <form>
                    <div class="mb-3">
                        <label for="inputTitle" class="form-label">Track Title</label>
                        <input type="text" class="form-control" id="inputTitle"
                               maxlength="250">
                    </div>
                    <div class="mb-3">
                        <label for="inputType" class="form-label">Track Type</label>

                        <select class="form-select" id="inputType">
                            <option th:each="activityOpt : ${T(com.cubetrek.database.TrackData.Activitytype).values()}"
                                    th:value="${activityOpt}"
                                    th:text="${activityOpt.displayValue}"
                            ></option>
                        </select>
                    </div>
                    <h6 class="mt-3">Favorite</h6>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="favoriteChecked"
                               onclick="setFavorite()">
                        <label class="form-check-label" for="favoriteChecked" id="favoriteCheckedLabel">Favorite</label>
                    </div>
                    <h6 class="mt-3">Privacy</h6>
                    <div class="form-check form-switch mt-3">
                        <input class="form-check-input" type="checkbox" id="publicChecked"
                               onclick="setTrackShare()">
                        <label class="form-check-label" for="publicChecked" id="publicCheckedLabel">Public</label>
                    </div>
                    <h6 class="mt-3">Hide or Delete Track</h6>
                    <button type="button" class="btn btn-primary btn-sm" onclick="clickhide(false)">Hide Track
                    </button>
                    <button type="button" class="btn btn-danger btn-sm" onclick="clickdelete(false)">Delete Track
                    </button>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveEdit()">Save</button>
            </div>
        </div>
    </div>
</div>


<div class="modal" id="confirmhidden" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Hide Track</h5>
            </div>
            <div class="modal-body">
                <p>Hiding a track will exclude it from the Dashboard and your totals.</p>
                <p>The only way to view hidden tracks later on is through the designated link on the dashboard.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal"
                        onclick="bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).show();">
                    Cancel
                </button>
                <button type="button" class="btn btn-primary" onclick="clickhide(true)">Hide Track</button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="confirmdelete" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Delete Track</h5>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this Track?</p>
                <p>This cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal"
                        onclick="bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).show();">
                    Cancel
                </button>
                <button type="button" class="btn btn-primary" onclick="clickdelete(true)">Delete Track</button>
            </div>
        </div>
    </div>
</div>
</body>
<script th:inline="javascript">
    var icons = {};
    /*[# th:each="activityOpt : ${T(com.cubetrek.database.TrackData.Activitytype).values()}"]*/
    icons[ /*[[${activityOpt}]]*/ ] =[ /*[[${activityOpt.iconName}]]*/ , /*[[${activityOpt.displayValue}]]*/ ];
    /*[/]*/

    var dataHeatmap = [(${activityHeatmapJSON})];

    var datamonthly = [(${monthlyTotalJSON})];

    var datayearly = [(${yearlyTotalJSON})];

    var datacumulative = [(${activityCumulativeJSON})];

</script>
<script th:if="${heartrateZones != null}" th:inline="javascript">
    var heartrateZones = [(${heartrateZones})];
</script>
<script th:inline="none">
    var parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");
    let metric = true;
    const miles_per_km = 0.621371;
    const feet_per_m = 3.28084;
    const datas = [];
    const bargraphdatasMonthly = [];
    const bargraphdatasYearly = [];

    const recenttablebody = document.getElementById("recenttablebody");
    var entries = new Map();


    const orderedActivityTypes = (!datacumulative || datacumulative.length === 0)
        ? [1,2,3,4]
        : Object.entries(
            datacumulative.reduce((acc, { activitytype }) => {
                acc[activitytype] = (acc[activitytype] || 0) + 1;
                return acc;
            }, {})
        )
            .sort((a, b) => b[1] - a[1])
            .map(item => parseInt(item[0]));

    for (let act of orderedActivityTypes) {
        var node = document.createElement("li");
        node.innerHTML = "<a class='dropdown-item' onclick='generateCumulativeGraph("+act+")'>"+icons[Object.keys(icons)[act]][1]+"</a>";
        document.getElementById("cumgraphDropdow").appendChild(node);
    }

    function generateCumulativeGraph(activitytype) {
        const thisYear = new Date().getFullYear();
        const thisYearString = thisYear.toString();

        const filteredData = datacumulative.filter(d => d.activitytype === activitytype);
        const parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S%Z");

        // Group and sum data by year
        let cumulativeData = {};
        filteredData.forEach(d => {
            const year = parseTime(d.trackdata_day).getFullYear();
            const date = (parseTime(d.trackdata_day)).setFullYear(thisYear);
            cumulativeData[year] = cumulativeData[year] || [];
            cumulativeData[year].push({date: date, dist: (d.day_dist/1000)*(metric?1:miles_per_km), show: true});
        });

        // Adding zero data point for the first day of each year if it doesn't exist
        Object.keys(cumulativeData).forEach(year => {
            const jan1 = new Date(thisYear, 0, 1);
            if (!cumulativeData[year].some(d => +d.date === +jan1)) {
                cumulativeData[year].push({
                    date: jan1,
                    dist: 0,
                    show: false
                });
            }
            cumulativeData[year].sort((a, b) => +a.date - +b.date); //sort
        });

        //last day of the year for the first year
        Object.keys(cumulativeData).forEach(year => {
            let lastDay;
            if (year === thisYearString) {
                lastDay = new Date();
            } else {
                lastDay = new Date(thisYear, 11, 31);
            }
            if (!cumulativeData[year].some(d => +d.date === +lastDay)) {
                cumulativeData[year].push({
                    date: lastDay,
                    dist: 0,
                    show: false
                });
            }
        });


        // Calculate cumulative sums
        Object.keys(cumulativeData).forEach(year => {
            cumulativeData[year].sort((a, b) => a.date - b.date);
            cumulativeData[year].reduce((acc, curr) => {
                curr.cumulative = acc + curr.dist;
                return curr.cumulative;
            }, 0);
        });

        d3.select("#cumgraph").select("svg").remove(); //clear if exists already
        const svg = d3.select("#cumgraph").append("svg");
        const cumgraphElement = d3.select("#cumgraph").node();
        const cumgraphWidth = cumgraphElement.getBoundingClientRect().width;
        const cumgraphHeight = 400;

        const margin = {top: 20, right: 0, bottom: 20, left: 50};
        let width = cumgraphWidth-margin.left-margin.right;
        let height = cumgraphHeight-margin.top-margin.bottom;
        svg
            .attr("width", width+margin.right+margin.left)
            .attr("height", height+margin.top+margin.bottom)
            .attr("viewBox", [0, 0, width+margin.right+margin.left, height+margin.top+margin.bottom])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            ;


        const x = d3.scaleTime().range([0, width]),
            y = d3.scaleLinear().range([height, 0]);

        const line = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.cumulative));

        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        x.domain([new Date(thisYear, 0, 1), new Date(thisYear, 11, 31)]);
        y.domain([0, d3.max(Object.values(cumulativeData).flat(), d => d.cumulative)]);
        // Draw lines for each year
        Object.keys(cumulativeData).forEach(year => {
            g.append("path")
                .datum(cumulativeData[year])
                .attr("fill", "none")
                .attr("stroke", year === (thisYearString) ? "#ff8001" : "darkgrey")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", year === (thisYearString) ? 3 : 1.5)
                .attr("d", line);

            g.selectAll("dot")
                .data(cumulativeData[year].filter(d => d.show === true))
                .enter().append("circle") // Adds a circle at each datapoint
                .attr("r", 3) // Radius of the dot
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.cumulative))
                .attr("fill", year === (thisYearString) ? "#ff8001" : "darkgrey");

        });


        // Mark current date
        if (cumulativeData[thisYearString]) {
            const lastDataPoint = cumulativeData[thisYearString][cumulativeData[thisYearString].length - 1];
            g.append("circle")
                .attr("r", 4)
                .attr("cx", x(lastDataPoint.date))
                .attr("cy", y(lastDataPoint.cumulative))
                .attr("fill", "#ff8001")
                .style("stroke", "#ff8001")
                .style("stroke-width", 3)
                .style("fill-opacity", 0.8)
                .attr("class", "blinking-dot");
        }

        // Define legend properties
        const legendSize = 10;
        const legendSpacing = 4;
        const legend = svg.append("g")
            .attr("transform", `translate(${width - 20}, ${height - 20 * Object.keys(cumulativeData).length})`);
        Object.keys(cumulativeData).forEach((year, index) => {
            legend.append("rect")
                .attr("x", 0)
                .attr("y", index * (legendSize + legendSpacing))
                .attr("width", legendSize)
                .attr("height", legendSize)
                .style("fill", year === (thisYearString) ? "#ff8001" : "darkgrey");
            legend.append("text")
                .attr("x", legendSize + legendSpacing)
                .attr("y", index * (legendSize + legendSpacing) + legendSize / 2)
                .attr("dy", ".35em")
                .text(year)
                .style("font-size", "12px")
                .style("text-anchor", "start")
                .style("alignment-baseline", "middle");
        });

        // Add axes
        g.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(d3.timeMonth.every(1)).tickFormat(d3.timeFormat("%B")));

        g.append("g")
            .call(d3.axisLeft(y))
            .call(g => g.append("text")
                .attr("id", "cumgraphhead")
                .attr("x", 0 - margin.left)
                .attr("y", -5)
                .attr("fill", "black")
                .attr("text-anchor", "start")
                .text("‚Üë Cumulative Distance ["+(metric?"km":"mi")+"]"));;
    }

    document.getElementById("cumgraphButton").innerText = icons[Object.keys(icons)[orderedActivityTypes[0]]][1];
    generateCumulativeGraph(orderedActivityTypes[0]);

    function prepareHeatmapdata() {
        for (var i=0; i<dataHeatmap.length; i++) {
            let date = parseDate(dataHeatmap[i].trackdata_day);
            date.setHours(12,0,0,0);
            let day_dist = (dataHeatmap[i].day_dist/1000);
            let day_elevationup = dataHeatmap[i].day_elevationup;
            let number = dataHeatmap[i].number;
            datas.push({'date' : date, 'day_dist' : day_dist, 'day_elevationup' : day_elevationup, 'number' : number});
        }

        var minDate = new Date(d3.min(datas, d => d.date));
        minDate.setMonth(0);
        minDate.setDate(1);
        var today = new Date();

        while (minDate <= today) {
            const found = datas.some(d => d.date.getTime() === minDate.getTime());
            if (!found) {
                datas.push({'date' : new Date(minDate)});
            }
            minDate.setDate(minDate.getDate() + 1);
        }
    }

    let bargraphType = "distance";
    let bargraphActivity = 2;
	let bargraphYearly = false;

	let barchart = [];

    function prepareBargraphdata() {
        for (var i=0; i<datamonthly.length; i++) {
            let date = parseDate(datamonthly[i].trackdata_month);
            date.setHours(12,0,0,0);
            let monthly_dist = (datamonthly[i].monthly_dist/1000);
            let activitytype = datamonthly[i].activitytype;
            bargraphdatasMonthly.push({'date' : date, 'monthly_dist' : monthly_dist, 'monthly_elevationup' : datamonthly[i].monthly_elevationup, 'activitytype' : activitytype});
        }
        if (bargraphdatasMonthly.length === 0) {
            bargraphdatasMonthly.push({'date' : new Date(new Date().setHours(12, 0, 0, 0)), 'monthly_dist' : 0, 'monthly_elevationup' : 0, 'activitytype' : 0});
        }

        for (var i=0; i<datayearly.length; i++) {
            let date = parseDate(datayearly[i].trackdata_year);
            date.setHours(12,0,0,0);
            let yearly_dist = (datayearly[i].yearly_dist/1000);
            let activitytype = datayearly[i].activitytype;
            bargraphdatasYearly.push({'date' : date, 'yearly_dist' : yearly_dist, 'yearly_elevationup' : datayearly[i].yearly_elevationup, 'activitytype' : activitytype});
        }
        if (bargraphdatasYearly.length === 0) {
            bargraphdatasYearly.push({'date' : new Date(new Date().setHours(12, 0, 0, 0)), 'yearly_dist' : 0, 'yearly_elevationup' : 0, 'activitytype' : 0});
        }

        const uniqueActivities = [
            ...new Set([
                ...bargraphdatasMonthly.map(item => item.activitytype),
                ...bargraphdatasYearly.map(item => item.activitytype)
            ])
        ];
        document.getElementById("barGraphButton").innerText = icons[Object.keys(icons)[uniqueActivities[0]]][1];
        bargraphActivity = uniqueActivities[0];
        for (let act of uniqueActivities) {
            var node = document.createElement("li");
            node.innerHTML = "<a class='dropdown-item' onclick='updateBargraphActivity("+act+")'>"+icons[Object.keys(icons)[act]][1]+"</a>";
            document.getElementById("barGraphDropdown").appendChild(node);
        }

        this.width = document.getElementById('bargraph').clientWidth;
        d3.select("#bargraph").select("svg").remove(); //clear if exists already
        this.svg = d3.select("#bargraph").append("svg");
        barchart = BarChart(this.svg, bargraphdatasMonthly, bargraphdatasYearly, bargraphActivity);
    }

    function updateBargraphActivity(activity) {
		document.getElementById("barGraphButton").innerText = icons[Object.keys(icons)[activity]][1];
        bargraphActivity = activity;
        updateBargraph();
    }

    function updateBargraphType(type) {
		switch (type) {
			case "distance":
				document.getElementById("barGraphButton2").innerText = "Distance";
				break;
			case "ascent":
				document.getElementById("barGraphButton2").innerText = "Ascent";
				break;
		}
        bargraphType = type;
        updateBargraph();
    }

	function updateBargraphTime() {
		bargraphYearly = !bargraphYearly;
		document.getElementById("barGraphButton3").innerText = (bargraphYearly ? "Yearly" : "Monthly");
        updateBargraph();
    }

    function updateBargraph() {
		barchart.update(bargraphActivity, bargraphType, bargraphYearly);
    }

    let heatmapType = "distance";

    function drawHeatmap() {

        d3.select("#graph").select("svg").remove(); //clear if exists already
        this.svg = d3.select("#graph").append("svg");
        const heatgraphElement = d3.select("#graph").node();
        this.width = heatgraphElement.getBoundingClientRect().width;

        Calendar(this.svg, datas, {
            x: d => d.date,
            y: d => {
                switch (heatmapType) {
                    case 'distance':
                        return d.day_dist;
                    case 'ascent':
                        return d.day_elevationup;
                    case 'number':
                        return d.number;
                }
            },
            width: this.width,
            cellSize: (this.width/60),
            weekday: "monday",
            colors: (function(){
                switch (heatmapType) {
                    case 'distance':
                        return d3.interpolateYlOrRd;
                    case 'ascent':
                        return d3.interpolateYlGn;
                    case 'number':
                        return d3.interpolateRdPu;
                }}()),
            formatingFunction: (function(){
                switch (heatmapType) {
                    case 'distance':
                        return formatLongdist;
                    case 'ascent':
                        return formatShortdist;
                    case 'number':
                        return formatNumberActivities;
                }}())
        });
    }

    function heatmapChange(type) {
        switch (type) {
            case 'distance':
                heatmapType = "distance";
                document.getElementById("heatmaptype").innerText = "Distance per Day";
                break;
            case 'ascent':
                heatmapType = "ascent";
                document.getElementById("heatmaptype").innerText = "Vertical Ascent per Day";
                break;
            case 'number':
                heatmapType = "number";
                document.getElementById("heatmaptype").innerText = "Number of Activities per Day";
                break;
        }
        drawHeatmap();
    }

    prepareHeatmapdata();
    prepareBargraphdata();
    settings();

    var tooltip = d3.select("body")
        .append("div")
        .style("position", "absolute")
        .style("z-index", "10")
        .style("visibility", "hidden")
        .style("background", "rgba(245, 245, 255, 0.6)");

    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/calendar-view
    function Calendar(svg, data, {
        x = ([x]) => x, // given d in data, returns the (temporal) x-value
        y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
        cellSize = 20, // width and height of an individual day, in pixels
        weekday = "monday", // either: weekday, sunday, or monday
        formatDay = i => "SMTWTFS"[i], // given a day number in [0, 6], the day-of-week label
        formatMonth = "%b", // format specifier string for months (above the chart)
        formatingFunction = formatShortdist,
        colors = d3.interpolateYlOrRd
    } = {}) {
        const heatgraphElement = d3.select("#graph").node();
        width = heatgraphElement.getBoundingClientRect().width;

        // Compute values.
        const X = d3.map(data, x);
        const Y = d3.map(data, y);
        const I = d3.range(X.length);

        const countDay = weekday === "sunday" ? i => i : i => (i + 6) % 7;
        const timeWeek = weekday === "sunday" ? d3.utcSunday : d3.utcMonday;
        const weekDays = weekday === "weekday" ? 5 : 7;
        const height = cellSize * (weekDays + 2);

        // Compute a color scale. This assumes a diverging color scheme where the pivot
        // is zero, and we want symmetric difference around zero.
        const max = d3.quantile(Y, 0.9975, Math.abs);
        const color = d3.scaleSequential([0, max], colors).unknown("#eee");

        // Construct formats.
        formatMonth = d3.utcFormat(formatMonth);

        // Group the index by year, in reverse input order. (Assuming that the input is
        // chronological, this will show years in reverse chronological order.)
        const years = d3.groups(I, i => X[i].getUTCFullYear()).reverse();

        function pathMonth(t) {
            const d = Math.max(0, Math.min(weekDays, countDay(t.getUTCDay())));
            const w = timeWeek.count(d3.utcYear(t), t);
            return `${d === 0 ? `M${w * cellSize},0`
                : d === weekDays ? `M${(w + 1) * cellSize},0`
                    : `M${(w + 1) * cellSize},0V${d * cellSize}H${w * cellSize}`}V${weekDays * cellSize}`;
        }

        svg
            .attr("width", width)
            .attr("height", height * years.length)
            .attr("viewBox", [0, 0, width, height * years.length])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "var(--bs-body-font-family)")
            .attr("font-size", "0.7rem");

        const year = svg.selectAll("g")
            .data(years)
            .join("g")
            .attr("transform", (d, i) => `translate(40.5,${height * i + cellSize * 1.5})`);

        year.append("text")
            .attr("x", -5)
            .attr("y", -5)
            .attr("font-weight", "bold")
            .attr("text-anchor", "end")
            .text(([key]) => key);

        year.append("g")
            .attr("text-anchor", "end")
            .selectAll("text")
            .data(weekday === "weekday" ? d3.range(1, 6) : d3.range(7))
            .join("text")
            .attr("x", -5)
            .attr("y", i => (countDay(i) + 0.5) * cellSize)
            .attr("dy", "0.31em")
            .text(formatDay);

        const formatDate = d3.utcFormat("%B %-d, %Y");
        const formatValue = color.tickFormat(100, "1f");

        const cell = year.append("g")
            .selectAll("rect")
            .data(weekday === "weekday"
                ? ([, I]) => I.filter(i => ![0, 6].includes(X[i].getUTCDay()))
                : ([, I]) => I)
            .join("rect")
            .attr("width", cellSize - 1)
            .attr("height", cellSize - 1)
            .attr("x", i => timeWeek.count(d3.utcYear(X[i]), X[i]) * cellSize + 0.5)
            .attr("y", i => countDay(X[i].getUTCDay()) * cellSize + 0.5)
            .attr("fill", i => color(Y[i]))
            .on("mouseover", function(e, i) {
				let thisRect = d3.select(this);
                tooltip.style("visibility", "visible");
                tooltip.style("top", (e.pageY-10)+"px").style("left",(e.pageX+10)+"px");
                tooltip.html(formatDate(X[i])+"<br>"+(Y[i] === undefined?"<i>No Activity</i>":formatingFunction(Y[i])));
            })
            .on("mouseout", function(e, i) {
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(e, i) {
                if (Y[i] !== undefined) {
                    clickDay(dataHeatmap[i].trackdata_day);
                }
            });

        const month = year.append("g")
            .selectAll("g")
            .data(([, I]) => d3.utcMonths(d3.utcMonth(X[I[0]]), X[I[I.length - 1]]))
            .join("g");

        month.filter((d, i) => i).append("path")
            .attr("fill", "none")
            .attr("stroke", "#fff")
            .attr("stroke-width", 3)
            .attr("d", pathMonth);

        month.append("text")
            .attr("x", d => timeWeek.count(d3.utcYear(d), timeWeek.ceil(d)) * cellSize + 2)
            .attr("y", -5)
            .text(formatMonth);

        return Object.assign(svg.node(), {scales: {color}});
    }

    const tablebodyPop = document.getElementById("poptable");

    function clickDay(date) {
        var dt = new Date(Date.parse(date));
        let year = dt.getUTCFullYear();
        let month = dt.getMonth();
        let day = dt.getDate();

        var url = "/activities_per_day?year="+year+"&month="+month+"&day="+day+"&timezone="+Intl.DateTimeFormat().resolvedOptions().timeZone;;

        fetch(url)
            .then(response => {
                if (response.status === 200) {
                    return response.json();
                } else {
                    console.log("ERROR");
                    //ignore error
                }
            })
            .then(data => {
                while (tablebodyPop.firstChild) { //remove everything first
                    tablebodyPop.removeChild(tablebodyPop.firstChild);
                }
                document.getElementById('heatmapModalTitle').innerText=
                    (new Date(Date.parse(data[0].datetrack))).toLocaleString([], {year: 'numeric', month: 'long', day: 'numeric',  weekday: "long"});
                for (var entry of data) {
                    var row = tablebodyPop.insertRow();
                    row.insertCell().innerHTML = "<img src='../assets/"+icons[entry.activitytype][0]+"' alt='"+icons[entry.activitytype][1]+"' height=20px>";
                    row.insertCell().innerHTML = (new Date(Date.parse(entry.datetrack))).toLocaleString([], {hour: '2-digit', minute: '2-digit'});
                    row.insertCell().innerHTML = (entry.favorite?"<img src='../assets/icon_favorite_select.svg' height='15px'>":"") + "<a href='/view/"+entry.id+"'>"+entry.title+"</a>";
                    row.insertCell().innerHTML = minToString(parseInt(entry.duration))+ " h";
                    row.insertCell().innerHTML = (entry.elevationup*(metric?1:feet_per_m)).toFixed(0) + (metric?" m":" ft");
                    row.insertCell().innerHTML = (parseFloat(entry.distance)/1000*(metric?1:miles_per_km)).toFixed(1) + (metric?" km":" mi");
                }
                bootstrap.Modal.getOrCreateInstance(document.getElementById('heatmapModal')).show();
            });
    }

    function BarChart(svg, data_monthly, data_yearly, activitytype, {
        height = 400,
        marginTop = 30, // top margin, in pixels
        marginRight = 0, // right margin, in pixels
        marginBottom = 40, // bottom margin, in pixels
        marginLeft = 60, // left margin, in pixels
        yRange = [height - marginBottom, marginTop], // [ymin, ymax]
        yFormat, // a format specifier string for the y-axis
        duration: initialDuration = 250, // transition duration, in milliseconds
        delay: initialDelay = (_, i) => i * 20 // per-element transition delay, in milliseconds
    } = {}) {

        const bargraphElement = d3.select("#bargraph").node();
        // Get the width of the #cumgraph element
        const width = bargraphElement.getBoundingClientRect().width;
        let xRange = [marginLeft, width - marginRight]; // [xmin, xmax]

        // Compute values.
        let X_monthly = d3.map(data_monthly.filter(d => d.activitytype === activitytype), d => d.date);
        let X_yearly = d3.map(data_yearly.filter(d => d.activitytype === activitytype), d => d.date);
        let Y_monthly = d3.map(data_monthly.filter(d => d.activitytype === activitytype), d => d.monthly_dist*(metric?1:miles_per_km));
        let Y_yearly = d3.map(data_yearly.filter(d => d.activitytype === activitytype), d => d.yearly_dist*(metric?1:miles_per_km));

        //xDomain
        let xDomain_monthly = new d3.InternSet(d3.map(data_monthly, d => d.date));
        const minDate = new Date(d3.min(xDomain_monthly));
		minDate.setMonth(0);
        const today = new Date();
		today.setMonth(11);
        xDomain_monthly = [];
        while (minDate <= today) {
            xDomain_monthly.push(new Date(minDate));
            minDate.setMonth(minDate.getMonth() + 1);
        }
		xDomain_monthly = [...new Set(xDomain_monthly)];

        let xDomain_yearly = new d3.InternSet(d3.map(data_yearly, d => d.date));
        const minDate_year = new Date(d3.min(xDomain_yearly));
        xDomain_yearly = [];
        while (minDate_year <= today) {
            xDomain_yearly.push(new Date(minDate_year));
            minDate_year.setFullYear(minDate_year.getFullYear() + 1);
        }
        xDomain_yearly = [...new Set(xDomain_yearly)];

		let yearDomain_monthly = new d3.InternSet(d3.map(xDomain_monthly, d => d.getFullYear()));
		let monthDomain_monthly = new d3.InternSet(d3.map(xDomain_monthly, d => d.getMonth()));

		const xScaleYear_monthly = d3.scaleBand().domain(yearDomain_monthly).range(xRange).paddingOuter(0).paddingInner(0.05);
		const xScaleMonth_monthly = d3.scaleBand().domain(monthDomain_monthly).range([0, xScaleYear_monthly.bandwidth()]).padding(0.05);

        let yearDomain_yearly = new d3.InternSet(d3.map(xDomain_yearly, d => d.getFullYear()));
        const xScaleYear_yearly = d3.scaleBand().domain(yearDomain_yearly).range(xRange).paddingOuter(0).paddingInner(0.05);


        //yDomain
        let yDomain = [0, d3.max(Y_monthly)];

        // Construct scales, axes, and formats.
        let yScale = d3.scaleLinear(yDomain, yRange);
        let yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

        svg
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .on("click", function(e, i) {
                updateBargraphTime();
            });

        const yGroup = svg.append("g")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(yAxis)
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick").call(grid))
            .call(g => g.append("text")
				.attr("id", "bargraphhead")
                .attr("x", -marginLeft)
                .attr("y", 10)
                .attr("fill", "black")
                .attr("text-anchor", "start")
                .text("‚Üë Distance ["+(metric?"km":"mi")+"]"));

		let xcolorsMonthly = d3.scaleOrdinal(xDomain_monthly, colors = d3.quantize(d3.interpolateHcl("#fafa6e", "#2A4858"), 12));
		let xcolorsYearly = d3.scaleOrdinal(xDomain_yearly, colors = d3.quantize(d3.interpolateHcl("#fafa6e", "#2A4858"), 12));

		var formatDate = d3.timeFormat("%B %Y");

        const rect_monthly = svg.append("g")
            .selectAll("rect")
            .data(xDomain_monthly)
            .join("rect")
			.each(function(d, i) {
				position_monthly(d3.select(this), d, "distance");
			}).attr("fill", i => xcolorsMonthly(i))
			.style("mix-blend-mode", "multiply");

        const rect_yearly = svg.append("g")
            .selectAll("rect")
            .data(xDomain_yearly)
            .join("rect")
            .each(function(d, i) {
                position_yearly(d3.select(this), d, "distance");
            }).attr("fill", i => xcolorsYearly(i))
            .style("mix-blend-mode", "multiply")
            .style("visibility", "hidden");

        const monthAxis = svg.append("g");

        for (let year of yearDomain_monthly) {
            const xAxis = d3.axisBottom(xScaleMonth_monthly).tickSize(0)
                .tickFormat(d => {
                    let date = new Date();
                    date.setDate(1);
                    date.setMonth(d);
                    return d3.timeFormat("%b")(date);
                });

            const axisGroup = monthAxis.append("g")
                .attr("transform", `translate(${xScaleYear_monthly(year)},${13 + height - marginBottom})`)
                .call(xAxis)
                .call(g => g.select(".domain").remove());

            // Rotate the text labels
            axisGroup.selectAll("text")
                .attr("transform", "rotate(90)")
                .style("text-anchor", "start")
                .attr("y", -7);
        }

		const xAxis_year_monthly = d3.axisBottom(xScaleYear_monthly).tickSize(0);
        const xAxis_year_yearly = d3.axisBottom(xScaleYear_yearly).tickSize(0);
		const yearaxis = svg.append("g")
				.attr("transform", `translate(0,${height - marginBottom})`)
				.call(xAxis_year_monthly);

        // A helper method for updating the position of bars.
        function position_monthly(rect, xdomaindate, measuretype) {
			let index = X_monthly.findIndex(element => element.getTime() === xdomaindate.getTime());
			let y = 0;
			if (index !== -1) {
				y = yScale(Y_monthly[index]);
			} else {
				y = yScale(0);
			}
			return rect
				.attr("width", xScaleMonth_monthly.bandwidth())
				.on("mouseover", function(e, i) {
					if (index < 0)
						return;

					tooltip.style("visibility", "visible");
					tooltip.style("top", (e.pageY-10)+"px").style("left",(e.pageX+10)+"px");

					switch (measuretype) {
					case 'distance':
						tooltip.html(Y_monthly[index].toFixed(1) + (metric?" km":" mi")+"<br>"+formatDate(X_monthly[index]));
						break;
					case 'ascent':
						tooltip.html(Y_monthly[index].toFixed(0) + (metric?" m":" ft")+"<br>"+formatDate(X_monthly[index]));
						break;
					}
				})
				.on("mouseout", function(e, i) {
					tooltip.style("visibility", "hidden");
				})
				.attr("x", xScaleYear_monthly(xdomaindate.getFullYear())+xScaleMonth_monthly(xdomaindate.getMonth()))
                .attr("width", xScaleMonth_monthly.bandwidth())
                .transition()
                .attr("y", y)
				.attr("height", yScale(0) - y);
        }

        function position_yearly(rect, xdomaindate, measuretype) {
            let index = X_yearly.findIndex(element => element.getTime() === xdomaindate.getTime());
            let y = 0;
            if (index != -1) {
                y = yScale(Y_yearly[index]);
            } else {
                y = yScale(0);
            }
            var height = yScale(0) - y;
            var rect= rect
                .attr("width", xScaleYear_yearly.bandwidth())
                .on("mouseover", function(e, i) {
                    if (index < 0)
                        return;

                    tooltip.style("visibility", "visible");
                    tooltip.style("top", (e.pageY-10)+"px").style("left",(e.pageX+10)+"px");

                    switch (measuretype) {
                        case 'distance':
                            tooltip.html(Y_yearly[index].toFixed(1) + (metric?" km":" mi")+"<br>"+X_yearly[index].getFullYear());
                            break;
                        case 'ascent':
                            tooltip.html(Y_yearly[index].toFixed(0) + (metric?" m":" ft")+"<br>"+X_yearly[index].getFullYear());
                            break;
                    }
                })
                .on("mouseout", function(e, i) {
                    tooltip.style("visibility", "hidden");
                })
                .attr("x", xScaleYear_yearly(xdomaindate.getFullYear()))
                .attr("width", xScaleYear_yearly.bandwidth())
                .transition()
                .attr("y", y)
                .attr("height", height);
            return rect;
        }

        // A helper method for generating grid lines on the y-axis.
        function grid(tick) {
			tick.selectAll("line").remove();
            return tick.append("line")
                .attr("class", "grid")
                .attr("x2", width - marginLeft - marginRight)
                .attr("stroke", "black")
                .attr("stroke-opacity", 0.1);
        }

        // Call chart.update(activitytype, measuretype, yearlySum) to transition to new data.
        return Object.assign(svg.node(), {
            update(activitytype, measuretype, yearlySum) {
                if (yearlySum) {
                    X_yearly = d3.map(data_yearly.filter(d => d.activitytype === activitytype), d => d.date);
                    switch (measuretype) {
                        case 'distance':
                            Y_yearly = d3.map(data_yearly.filter(d => d.activitytype === activitytype), d => d.yearly_dist*(metric?1:miles_per_km));
                            document.getElementById("bargraphhead").innerHTML = "‚Üë Distance ["+(metric?"km":"mi")+"]";
                            break;
                        case 'ascent':
                            Y_yearly = d3.map(data_yearly.filter(d => d.activitytype === activitytype), d => d.yearly_elevationup*(metric?1:feet_per_m));
                            document.getElementById("bargraphhead").innerHTML = "‚Üë Vertical Ascent ["+(metric?"m":"ft")+"]";
                            break;
                    }
                    yearaxis.transition().call(xAxis_year_yearly);
                    monthAxis.style("visibility", "hidden");
                    yDomain = [0, d3.max(Y_yearly)];
                } else {
                    X_monthly = d3.map(data_monthly.filter(d => d.activitytype === activitytype), d => d.date);
                    switch (measuretype) {
                        case 'distance':
                            Y_monthly = d3.map(data_monthly.filter(d => d.activitytype === activitytype), d => d.monthly_dist*(metric?1:miles_per_km));
                            document.getElementById("bargraphhead").innerHTML = "‚Üë Distance ["+(metric?"km":"mi")+"]";
                            break;
                        case 'ascent':
                            Y_monthly = d3.map(data_monthly.filter(d => d.activitytype === activitytype), d => d.monthly_elevationup*(metric?1:feet_per_m));
                            document.getElementById("bargraphhead").innerHTML = "‚Üë Vertical Ascent ["+(metric?"m":"ft")+"]";
                            break;
                    }
                    yearaxis.transition().call(xAxis_year_monthly);
                    monthAxis.style("visibility", "visible");
                    yDomain = [0, d3.max(Y_monthly)];
                }


                yScale = d3.scaleLinear(yDomain, yRange);
                yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

                yGroup.transition().call(yAxis);
                yGroup.call(g => g.selectAll(".tick").call(grid));

                if (yearlySum) {
                    rect_yearly
                        .style("visibility", "visible")
                        //.transition().duration(500).style("opacity", 1)
                        .each(function(d, i) {
                        position_yearly(d3.select(this), d, measuretype);
                        d3.select(this).attr("fill", i => {return xcolorsYearly(i)});
                        });

                    rect_monthly.style("visibility","hidden");
                } else {
                    rect_monthly.style("visibility", "visible")
                        //.transition().duration(500).style("opacity", 1)
                        .each(function(d, i) {
                        position_monthly(d3.select(this), d, measuretype);
                        d3.select(this).attr("fill", i => {return xcolorsMonthly(i)});
                        });

                    rect_yearly.style("visibility","hidden");
                }
            }
        });
    }

    function settings() {
        if (localStorage.getItem("metric") === null) {
            localStorage.setItem("metric", true);
        } else {
            metric = (localStorage.getItem("metric")==="true");
        }

        if (metric) {
            document.getElementById("metricChecked").checked = true;
            setMetric();
        } else {
            document.getElementById("metricChecked").checked = false;
            setMetric();
        }
    }

    function clickSettingsMetric() {
        metric = document.getElementById("metricChecked").checked;
        localStorage.setItem("metric",metric);
        setMetric();
    }

    function setMetric() {
        document.getElementById("metricCheckedLabel").innerText=(metric?"Metric Units":"Imperial Units");
        drawHeatmap();
        updateBargraph('distance', 'Running');
        formatValues();
        fetchData();
    }

    function minToString(minutes) {
        var m = minutes % 60;
        var h = (minutes-m)/60;
        return h.toString() + ":" + (m<10?"0":"") + m.toString();
    }

    function formatShortdist(value) {
        return (value *(metric?1:feet_per_m)).toFixed(0)+" "+(metric?"m":"ft");
    }

    function formatNumberActivities(value) {
        return value+" " + (value>1?"Activities":"Activity");
    }


    function formatLongdist(value) {
        return (value *(metric?1:miles_per_km)).toFixed(1)+" "+(metric?"km":"mi");
    }

    function formatValues() {
        document.querySelectorAll('[data-duration]').forEach(function(element) {
            element.innerText = minToString(element.dataset.duration)+" h";
        });

        document.querySelectorAll('[data-datetime]').forEach(function(element) {
            element.innerText = (new Date(Date.parse(element.dataset.datetime))).toLocaleString([], {year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit'});
        });

        document.querySelectorAll('[data-date]').forEach(function(element) {
            element.innerText = (new Date(Date.parse(element.dataset.date))).toLocaleString([], {year: 'numeric', month: 'numeric', day: 'numeric'});
        });

        document.querySelectorAll('[data-shortdist]').forEach(function(element) {
            element.innerText = formatShortdist(element.dataset.shortdist);
        });

        document.querySelectorAll('[data-longdist]').forEach(function(element) {
            element.innerText = formatLongdist(element.dataset.longdist/1000);
        });
    }

    window.addEventListener("resize", function () {
        drawHeatmap();
        updateBargraph('distance', 'Running');
    });

    function fetchData() {
        entries = new Map();
        while (recenttablebody.firstChild) {
            recenttablebody.removeChild(recenttablebody.firstChild);
        }
        const entriesPerFetch = 5;
        var url = "/activities_ajax?page=0&size="+entriesPerFetch+"&sortby=datetrack&descending=true";

        fetch(url)
            .then(response => {100
                if (response.status === 200) {
                    return response.json();
                } else {
                    document.getElementById("errorbox").style.display = 'block';
                }
            })
            .then(data => listData(data));
    }

    function listData(data) {
        for (var entry of data) {
            entries.set(entry.id, entry);
            let newRow = document.createElement('div');
            newRow.id="r"+entry.id;
            newRow.classList.add("shadow-sm", "col-12", "p-1", "mb-3","bg-body-tertiary", "rounded", "position-relative");
            recenttablebody.appendChild(newRow);
            addRowInfo(newRow, entry);
        }
    }

    async function addRowInfo(row, entry) {
        row.innerHTML =
            `
    <a type="button" class="btn btn-outline-secondary btn-sm position-absolute top-0 end-0 me-2" href="#" onclick="menu(${entry.id}); return false;">...</a>
    <div class='row display-6 ms-1 mb-2' onclick="window.location.href='/view2d/${entry.id}';" style='cursor: pointer;'>
        <span class="p-0 m-0"><img src='../assets/${icons[entry.activitytype][0]}' alt='${icons[entry.activitytype][1]}' height="30">${entry.title}</span>
    </div>
    <div class='row'>
        <div class="col-lg-4 d-flex flex-column justify-content-center">
            <div class="col fs-6">
                ${entry.favorite ? "<img src='../assets/icon_favorite_select.svg' height='20px'>" : ""}
                ${(new Date(Date.parse(entry.datetrack))).toLocaleString([], {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })}
            </div>
            <a href="/view2d/${entry.id}"><img class="img-fluid rounded ps-1" src='/api/static_map/${entry.id}/500x300.png' alt="Map"></a>
        </div>
        <div class="col-lg-4 d-flex flex-wrap">
            <div class="m-2"><span class='fw-light'>Duration</span> <span class='fs-3'>${minToString(parseInt(entry.duration))} h</span></div>
            <div class="m-2"><span class='fw-light'>Ascent</span> <span class='fs-3'>${(entry.elevationup * (metric ? 1 : feet_per_m)).toFixed(0) + (metric ? " m" : " ft")}</span></div>
            <div class="m-2"><span class='fw-light'>Distance</span> <span class='fs-3'>${(parseFloat(entry.distance) / 1000 * (metric ? 1 : miles_per_km)).toFixed(1) + (metric ? " km" : " mi")}</span></div>
            <div class="m-2"><span class='fw-light'>Avg Speed</span> <span class='fs-3'>${((parseFloat(entry.distance) / 1000) / (parseFloat(entry.duration) / 60) * (metric ? 1 : miles_per_km)).toFixed(1) + (metric ? " km/h" : " mi/h")}</span></div>
            <div class="m-2"><span class='fw-light'>Pace</span> <span class="fs-3">${minFractionToString(parseFloat(entry.duration) / (parseFloat(entry.distance) / 1000 * (metric ? 1 : miles_per_km)))} ${metric ? "min/km" : "min/mi"}</span></div>
        </div>
        <div class="col-lg-4 p-3">
            <div class="d-flex flex-column ${entry.hasHeartrate ? "h-50":"h-100"} ">
                <div class="flex-grow-1">
                    <a href="${entry.trackgroup ? '/matching/' + entry.trackgroup : '/view/' + entry.id}">
                        <div id="graph${entry.id}" style="width: 100%; height: 100%; min-height: 60px;"></div>
                    </a>
                </div>
                ${entry.trackgroup ? "<span class='fw-light'>Percentile</span> <span class='fs-6' id='trackgroupRank" + entry.id + "'></span>" : "<span class='fw-light mt-3'>Highest Point ASL</span><span class='fs-6'>" + (entry.highestpoint * (metric ? 1 : feet_per_m)).toFixed(0) + (metric ? " m" : " ft") + "</span>"}
            </div>
            ${entry.hasHeartrate ?
            `<div class="d-flex flex-row h-50">
                <div class="flex-grow-1 col">
                    <a href="/view/${entry.id}">
                        <div id="heartrate${entry.id}" style="width: 100%; height: 100%; min-height: 60px;"></div>
                    </a>
                </div>
                <div class="col d-flex flex-column justify-content-center">
                    <span class='fw-light mt-3'>Average Heartrate</span><span id="heartrate_avg${entry.id}" class='fs-6'>666</span>
                    <span class='fw-light mt-3'>Max Heartrate</span><span id="heartrate_max${entry.id}" class='fs-6'>666</span>
                </div>
            </div>` : ""}
        </div>
    </div>
            `;

        let convertedData;
        if (entry.hasHeartrate || !entry.trackgroup) {
            var jsonData = await fetchgeojson(entry.id);
            convertedData = new ConvertedDatas(jsonData);
        }

        if (entry.trackgroup) {
            const matchingGraph = new MatchingGraph("graph"+entry.id, entry.trackgroup, entry.id);
            document.getElementById("trackgroupRank"+entry.id).innerText = await matchingGraph.initialize();
        } else {
            const altitudeGraph = new AltitudeGraph("graph"+entry.id, entry.id);
            altitudeGraph.initialize(convertedData);
        }

        if (entry.hasHeartrate) {
            const heartrateGraph = new GraphHeartrate(convertedData, document.getElementById("heartrate"+entry.id), document.getElementById("heartrate_avg"+entry.id), document.getElementById("heartrate_max"+entry.id));
        }

/**
        row.setAttribute("onclick","openPane("+entry.id+");");
        row.insertCell().innerHTML = "<img src='../assets/"+icons[entry.activitytype][0]+"' alt='"+icons[entry.activitytype][1]+"' height=20px>";
        row.insertCell().innerHTML = (new Date(Date.parse(entry.datetrack))).toLocaleString();
        row.insertCell().innerHTML = (entry.favorite?"<img src='../assets/icon_favorite_select.svg' height='15px'>":"") + "<a href='/view/"+entry.id+"'>"+entry.title+"</a>";
        row.insertCell().innerHTML = minToString(parseInt(entry.duration))+ " h";
        row.insertCell().innerHTML = (entry.elevationup*(metric?1:feet_per_m)).toFixed(0) + (metric?" m":" ft");
        row.insertCell().innerHTML = (parseFloat(entry.distance)/1000*(metric?1:miles_per_km)).toFixed(1) + (metric?" km":" mi");
        row.insertCell().innerHTML = (entry.trackgroup?"<a href='/matching/"+entry.trackgroup+"'><img title='Matching Activities' src='/assets/matched.svg'></a>":"");
 **/
    }

    var menu = function(id) {
        document.getElementById("successmessageedit").style.display = "none";
        selectedtrackid = id;
        var entry = entries.get(id);
        bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).show();
        document.getElementById("inputTitle").value = (new DOMParser().parseFromString(entry.title, "text/html")).documentElement.textContent ;
        document.getElementById("inputType").value = entry.activitytype;
        document.getElementById("favoriteChecked").checked = entry.favorite;

        if (entry.favorite) {
            document.getElementById("favoriteChecked").checked = true;
            document.getElementById("favoriteCheckedLabel").innerText = "Favorite";
        } else {
            document.getElementById("favoriteChecked").checked = false;
            document.getElementById("favoriteCheckedLabel").innerText = "Not in your Favorites List";
        }

        if (entry.sharing === "PUBLIC") {
            document.getElementById("publicChecked").checked = true;
            document.getElementById("publicCheckedLabel").innerText = "Public, anyone with the link can view this track";
        } else {
            document.getElementById("publicChecked").checked = false;
            document.getElementById("publicCheckedLabel").innerText = "Private, only you can view this track";
        }
    }

    const root = "../api/";

    function clickdelete(confirmed) {
        if (!confirmed) {
            bootstrap.Modal.getOrCreateInstance(document.getElementById('confirmdelete')).show();
            bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).hide();
            return;
        }
        fetch(root + "modify/id=" + selectedtrackid, {
            method: "DELETE"
        }).then(res => {
            res.json().then(response => {
                if (res.ok) {
                    deleteRow(selectedtrackid);
                    bootstrap.Modal.getOrCreateInstance(document.getElementById('confirmdelete')).hide();
                } else {
                    //not good
                }
            });
        }).catch(error => {
            console.log("--error");
            console.log(error);
        });
    }

    function clickhide(confirmed) {
        if (!confirmed) {
            bootstrap.Modal.getOrCreateInstance(document.getElementById('confirmhidden')).show();
            bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).hide();
            return;
        }
        fetch(root+"modify/id="+selectedtrackid+"&hidden=true", {
            method: "GET"
        }).then(res => {
            res.json().then(response => {
                if (res.ok) {
                    bootstrap.Modal.getOrCreateInstance(document.getElementById('confirmhidden')).hide();
                    deleteRow(selectedtrackid);
                } else {
                    //not good
                }
            });
        }).catch(error => {
            console.log("--error");
            console.log(error);
        });
    }

    function setFavorite() {
        document.getElementById("favoriteChecked")

        if (document.getElementById("favoriteChecked").checked) {
            document.getElementById("favoriteCheckedLabel").innerText = "Favorite";
        } else {
            document.getElementById("favoriteCheckedLabel").innerText = "Not in your Favorites List";
        }
    }

    function setTrackShare() {
        document.getElementById("publicChecked")

        if (!document.getElementById("publicChecked").checked) {
            document.getElementById("publicCheckedLabel").innerText = "Private, only you can view this track";
        } else {
            document.getElementById("publicCheckedLabel").innerText = "Public, anyone with the link can view this track";
        }
    }

    document.getElementById("inputTitle").addEventListener("keypress", function (event) {
        if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation()
            event.stopImmediatePropagation();
            saveEdit();
        }
    });

    function saveEdit() {
        let currentEntry = entries.get(selectedtrackid);
        let editTitle = document.getElementById("inputTitle").value;
        let editType = document.getElementById("inputType").value;
        let editFavorite = document.getElementById("favoriteChecked").checked;
        let editShared = (document.getElementById("publicChecked").checked ? "PUBLIC" : "PRIVATE");

        if (editTitle !== currentEntry.title || editType !== currentEntry.activitytype ) {
            let data = {index: selectedtrackid, title: editTitle, activitytype: editType};

            fetch(root+"modify", {
                method: "POST",
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            }).then(res => {
                res.json().then(response => {
                    if (res.ok) {
                        document.getElementById("successmessageedit").innerText = "Changes saved";
                        document.getElementById("successmessageedit").style.display = "block";
                    } else {
                        document.getElementById("errormessageedit").innerText = response.response;
                        document.getElementById("errormessageedit").style.display = "block";
                    }
                });
            }).catch(error => {
                console.log("--error");
                console.log(error);
            });
        }

        if (editFavorite !== currentEntry.favorite) {
            fetch(root+"modify/id="+selectedtrackid+"&favorite="+(editFavorite), {
                method: "GET"
            }).then(res => {
                res.json().then(response => {
                    if (res.ok) {

                    } else {
                        //not good
                    }
                });
            }).catch(error => {
                console.log("--error");
                console.log(error);
            });
        }

        if (editShared !== currentEntry.sharing) {
            fetch(root+"modify/id="+selectedtrackid+"&sharing="+editShared, {
                method: "GET"
            }).then(res => {
                res.json().then(response => {
                    if (res.ok) {

                    } else {
                        //not good
                    }
                });
            }).catch(error => {
                console.log("--error");
                console.log(error);
            });
        }

        entries.get(selectedtrackid).title = editTitle;
        entries.get(selectedtrackid).activitytype = editType;
        entries.get(selectedtrackid).favorite = editFavorite;
        entries.get(selectedtrackid).sharing = editShared;

        var row = document.getElementById("r"+selectedtrackid);
        row.innerHTML="";
        addRowInfo(row, entries.get(selectedtrackid));
        bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).hide();
    }

    async function deleteRow(rowid)
    {
        var row = document.getElementById("r"+rowid);
        row.style.transition = '0.8s';
        row.style.opacity = 0;
        await new Promise(resolve => setTimeout(resolve, 1000));
        row.parentNode.removeChild(row);
    }

    async function fetchgeojson(trackid) {
        var url = "/api/geojson/" + trackid + ".geojson";
        try {
            let response = await fetch(url);
            if (response.status === 200) {
                return await response.json();
            } else {
                document.getElementById("errorbox").style.display = 'block';
                // Optionally, you can reject the promise or throw an error here
                throw new Error("Failed to fetch GeoJSON");
            }
        } catch (error) {
            console.error(error);
            // Handle the error as needed
        }
    }

    class AltitudeGraph {

        async initialize(convertedData) {
            this.datas = convertedData.datas;
            this.yScale = d3.scaleLinear().domain(d3.extent(this.datas, function (d) {
                return (d.altitude * (metric ? 1 : feet_per_m));
            }));
            this.functionpath.y((d) => {
                return this.yScale(d.altitude * (metric ? 1 : feet_per_m))
            });

            this.xScale = d3.scaleLinear().domain(d3.extent(this.datas, function (d) {
                return (d.distance * (metric ? 1 / 1000 : miles_per_km / 1000));
            }));
            this.functionpath.x((d) => {
                return this.xScale(d.distance * (metric ? 1 / 1000 : miles_per_km / 1000))
            });

            //this.xAxisLabel = d3.axisBottom(this.xScale);
            //this.yAxisLabel = d3.axisLeft(this.yScale);

            this.yScale.range([this.height, 0]);
            this.xScale.range([0, this.width]);
            this.svg.append("path")
                .datum(this.datas)
                .attr("fill", "url(#altitude-gradient)") // Use the defined gradient
                .attr("class", "datapath")
                //.attr("d", this.functionpath)
                .attr("d", this.areaPath); // Use the area generator
        }

        constructor(divname) {

            this.margingraph = {top: 0, right: 10, bottom: 0, left: 0};

            this.width = document.getElementById(divname).clientWidth - this.margingraph.left - this.margingraph.right;
            this.height = document.getElementById(divname).clientHeight - this.margingraph.top - this.margingraph.bottom;

            d3.select("#" + divname).select("svg").remove(); //clear if exists already
            this.svg = d3.select("#" + divname)
                .append("svg")
                .attr("width", this.width + this.margingraph.left + this.margingraph.right)
                .attr("height", this.height + this.margingraph.top + this.margingraph.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + this.margingraph.left + "," + this.margingraph.top + ")");

            this.functionpath = d3.line();

            this.areaPath = d3.area()
                .x((d) => {
                    return this.xScale(d.distance * (metric ? 1 / 1000 : miles_per_km / 1000));
                })
                .y0(this.height) // Bottom of the graph
                .y1((d) => {
                    return this.yScale(d.altitude * (metric ? 1 : feet_per_m));
                });
        }
    }


    async function fetchmatchingActivities(groupid) {
        var url = "/api/matching/" + groupid;
        try {
            let response = await fetch(url);
            if (response.status === 200) {
                return await response.json();
            } else {
                document.getElementById("errorbox").style.display = 'block';
                // Optionally, you can reject the promise or throw an error here
                throw new Error("Failed to fetch matching activities");
            }
        } catch (error) {
            console.error(error);
            // Handle the error as needed
        }
    }

    class MatchingGraph {

        async initialize() {
            var jsonData = await fetchmatchingActivities(this.groupid);

            this.datas = [];
            let count = 0;
            for (const entry of jsonData) {
                this.datas.push({'id' : entry.id, 'pace' : ((entry.duration/entry.distance)*1000)*(metric?1:miles_per_km), 'date' : new Date(entry.datetrack),  'xpos' : count++});
            }
            const pace = this.datas.find(entry => entry.id === this.trackid).pace;
            const sortedPaces = this.datas.map(d => d.pace).sort(d3.ascending);
            const rank = (d3.bisectLeft(sortedPaces, pace));// / sortedPaces.length * 100;
            this.textRank = (rank<=sortedPaces.length/2)?"Top " + Math.round(((rank+1)/ sortedPaces.length * 100)) + "% Rank":"Bottom " + Math.round(100-(rank/ sortedPaces.length * 100)) + "% Rank";

            this.datas.splice(15);

            this.colorScale = d3.scaleSequential(d3.interpolatePlasma)
                .domain(d3.extent(this.datas, function (d) { return d.pace; }).reverse());

            this.xscale = d3.scaleLinear()
                .domain(d3.extent(this.datas, function(d) { return d.xpos}))
                .range([ this.width, 0]);

            this.yscale = d3.scaleLinear()
                .domain(d3.extent(this.datas, function(d) { return d.pace}))
                .range([ 0, this.height ]);

            this.path = this.svg.append("path")
                .datum(this.datas)
                .attr("fill", "none")
                .attr("stroke", "#ff8001")
                .attr("stroke-width", 1.5)
                .transition()
                .attr("d", d3.line()
                    .curve(d3.curveBasis) // Just add that to have a curve instead of segments
                    .x(function (d) {
                        return this.xscale(d.xpos);
                    }.bind(this))
                    .y(function (d) {
                        return this.yscale(d.pace)
                    }.bind(this))
                )

            this.circles = this.svg.append("g").selectAll("dot").data(this.datas).enter().append("circle")
                .attr("id", function (d) {
                    return "c" + d.id
                })
                .attr("cy", function (d) {
                    return this.yscale(d.pace)
                }.bind(this))
                .transition()
                .attr("cx", function (d) {
                    return this.xscale(d.xpos);
                }.bind(this))
                .attr("r", 5)
                .attr("stroke", "#101010")
                .attr("stroke-width", 1)
                .style("fill", "rgba(68,146,220,0.42)")
                .filter(function (d) {
                    return d.id === this.trackid
                }.bind(this))
                .attr("stroke", "#fa7c7c")
                .attr("stroke-width", 5)
                .style("fill", "#000000");



            return this.textRank;
        }

        constructor(divname, groupid, trackid) {
            this.groupid = groupid;
            this.trackid = trackid;

            this.margingraph = {top: 10, right: 10, bottom: 20, left: 5};

            this.width = document.getElementById(divname).clientWidth - this.margingraph.left - this.margingraph.right,
                this.height = document.getElementById(divname).clientHeight - this.margingraph.top - this.margingraph.bottom;

            d3.select("#" + divname).select("svg").remove(); //clear if exists already
            this.svg = d3.select("#" + divname)
                .append("svg")
                .attr("width", this.width + this.margingraph.left + this.margingraph.right)
                .attr("height", this.height + this.margingraph.top + this.margingraph.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + this.margingraph.left + "," + this.margingraph.top + ")");

        }

    }

    function minFractionToString(minutes) {
        var seconds = minutes*60;
        var sec = seconds % 60;
        var min = (seconds-sec)/60;
        sec = Math.round(sec);
        return min.toString() + ":" + (sec<10?"0":"") + (sec.toFixed(0)).toString();
    }


</script>

<script type="module">
    import { ConvertedDatas, GraphHeartrate } from "../js/graph.js";
    window.ConvertedDatas = ConvertedDatas;
    window.GraphHeartrate = GraphHeartrate;
</script>
</html>